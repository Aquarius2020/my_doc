#### 网络编程的主要问题

- 如何找到网络上的主机
- 找到主机后如何传输数据

#### 网络协议

- 计算机交换数据事先定义好的规则. 如数据格式, 是否需要应答

#### 网络协议分层

- 分割大问题为小问题. 简化问题复杂度
- 灵活性好. 中间一层发生变化时其他层不受影响.

#### TCP/IP 模型

- 应用层     http, ftp, dns, rip
- 传输层     tcp / udp
  - 数据传输协议
- 网络层     ip
  - 控制网络运行. 数据分组在逻辑网络中如何传递
- 数据链路层
  - 控制物理 bit 流传输



#### TCP UDP

| TCP                                      | UDP                                |
| ---------------------------------------- | ---------------------------------- |
| 面向字节流. 一个数据包拆分成多个分组发送 | 面向报文. 一个报文一次发完         |
| 点对点                                   | 广播 (一对一,一对多,多对一,多对多) |
|                                          |                                    |



#### ARP 协议

根据 ip 找物理地址.

- 每个主机有一个 arp 高速缓存. **存储`当前局域网`内所有主机的 ip - mac**
- 通过向**局域网发送 arp 广播**来获取当前网络的 ip-mac 映射关系



#### 什么是NAT (Network Address Translation, 网络地址转换)？

用于解决 ipv4 地址不足的问题. 将内网地址转化为公网地址.



#### 从输入址到获得页面的过程

- 浏览器查 DNS 获取 ip
  - 自身 dns 缓存; 操作系统 dns 缓存; 读取本地 host 文件; 本地 dns 服务器查询.
- 获取 ip 后, 浏览器开始建立 tcp 链接.  http 默认拼上 80 端口. https 默认拼上 443 端口
- tcp 建立好后,开始发送 http 请求
- 服务器收到请求处理结果, 并返回给浏览器
- 浏览器解析结果, 如果有静态资源的引用, 则重复 4
- 浏览器获取到请求资源并渲染页面



#### TCP 三次握手

- SYN=1  seq=M            							 #                                         
- SYN=1, ACK=1, ack =M+1, seq = N      # 此时,建立了一半
- ACK=1,ack=N+1                                     # 此时,建立完成

能建立可信的链接是是 发送 SYN 时都会附带一个随机数, 只有 对方 ack 中附带的是 随机数+1 才认为是当前要建立的



#### 可以是两次握手吗

1.已失效的报文可能会重新到达服务端,进而建立一个无效的链接
		如 client 发出的请求并没有丢失,只是在某个网络中滞留的时间较长, server 会误以为这是 client 发起的一个新链接. 而采用三次握手,这种情况 server 会向服务端确认, 就可以避免这种情况. 从而避免资源浪费

两次握手只能保证客户端链接是可信的. 服务端必须也发送验证消息才行.



#### 三次握手,如果客户端的 ack 未到达服务器,会怎样

- server 端.由于灭有收到 ack 确认, 会每个 3 秒重发 syn+ack, 默认重发 5 次,之后进入 close 状态.
- client 端.
  - server 端超时重发阶段, 客户端发送 ack , 服务端进度 establish 状态
  - server 进入 close 状态, 客户端发送 ack, 服务端会以 rst 包应答



#### 已建立的链接,客户端出现了故障怎么办

服务端每收到一次客户端的请求后都会复位一个计时器,默认 2 小时. 如果 2 小时没有收到任何数据, 服务端会每隔 75 秒发送一个探测报文, 连续发 10 个没有消息后 服务端会关闭连接.



#### 初始序列号是什么

发送数据的版本号



#### TCP 的四次挥手

每一端关闭连接时都需要两次挥手`(fin+ack)`

- client 发送 fin, 进入 fin_wait_1
- server 收到 fin, 发送 ack, 进入 close_wait
- client 收到 ack, 进入 fin_wait_2
- ----------- 以上, client 向客户端的 close 关闭 --------
- server 发送 fin, 进入 last_ack
- client 收到 fin , 发送 ack ,进入 time_wait
- server 收到 ack 进入 close



最后 client 在 time_wait 需要等待两个 报文最长寿命(2*MSL): 如果 server 没有收到最后的 ack 时, 势必会在发送 fin 来结束, client 的等待就是为了确保最后的 ack 到达 server

server 端的 close_wait 只是说明自己还有一些事需要做,暂时先不 close, 等自己需要 close 的时候再发送 fin



#### 如果二次挥手服务器的 ack 没有送达客户端会怎样

client 认为 fin 丢失了,会重发 fin

换个思路理解更简单.  客户端远程调用了一个 close 函数, 拿返回值失败了, 当然是重新调一次.

一来一回看作是一次函数调用, 那么整个 TCP 关闭实际上可以看作是两次远程调用.



#### 什么是 socket

网络上两个程序通过一个双向的通讯连接交换数据, 这个双向链路为一个 socket.

socket 连接就是所谓的长连接, 除非有网络波动, 否则是不会主动断开的



#### 什么是 http 协议

客户端与服务器之间实现可靠的传输文字,图片,音频,视频等超文本数据的规范.
http 属于应用层



#### socket 和 http 的应用场景

- socket 是长连接, 不会主动断掉, 适合网络游戏,直播,视频等
- http 属于短连接, 服务端与客户端发送一次请求后, 服务端会立即断开. 适用网络服务,网站等.



#### http https

- https 需要 ca 证书
- http 默认 80 端口. https 默认 443
- http 明文传输. https ssl 加密传输



#### https 过程



#### http 请求过程

- 建立 tcp 链接
- 发送请求        (请求行,空行,请求头)
- 服务器响应    (响应头,空行,响应体)
- 服务器关闭 tcp 链接



#### http 状态码分类

- 1xx.  请求已接收,正在处理
- 2xx.  成功
- 3xx.  重定向
- 4xx.
- 5xx



#### get 和 post

根本区别在于传输数据的位置



#### http 版本

- 1.0 无状态. 每次请求后立即断开
- 1.1 tcp 可以保持连接 (keepConnect). 可以复用. 可以同时发多个 http 请求
- 2.0 
  - 二进制分帧: 采用二进制格式封装
  - 首部压缩: 设计了专门的 hpack 算法压缩首部
  - 流量控制
  - 多路复用: 可以在共享 tcp 链接的基础上同时发送多个请求和影响
  - 请求优先级: 
  - 服务推送: 就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资 源无 需客户端明确的请求



#### 对称加密和非对称加密





#### cookie 和 session

http 是无状态的, 通过 cookie 和 session 可以实现有状态的 http

- cookie
  以 k-v 形式保存的用户数据, 用户发起 http 请求时携带上 cookie
- session
  服务器存储用户数据, 用户通过sessionid 来使用.
  用户发起 http 请求时通过 cookie 或者其他方式传输 sessionid, 服务器根据此 id 取索引用户数据

区别:

- cookie 放在客户端上,安全性差
- cookie 保存的数据不能超过 4k, session 无限制. 但是,考虑到 session 都是放在服务器上的,保存的 session 越多越消耗服务器资源















































