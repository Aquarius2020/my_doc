

##### on



##### where



#### 连接的原理

##### 嵌套循环连接

```python
for item in 驱动表+驱动表的 where 条件：
	for item2 in 在被驱动表+where 条件 +连接条件:
    符合条件的发送客户端
```

特点：驱动表访问一次，被驱动表可能访问多次，访问次数取决于结果集的大小

> 结果集是一个抽象的概念，嵌套循环 join 依旧是查找一条符合的条件就给客户端发送一条数据，而不是先查出来放某个位置

> 被驱动表会访问多次，所以可以建索引来加快连接的速度。

```sql
select * from t1,t2 where t1.c1>1 and t2.c1>2 and t1.m=t2.m
-- 第一层循环的 sql
select * from t1 where t1.c1=2;    -- 假设第一条符合的数据是 t1.c1==2,t1.m=99，这条 sql 是虚假的, t1.c1 直接遍历即可
-- 第二层 sql
select * from t2 where t2.m=99 and t2.c1>2   -- 相当与连接条件拼到 where 中了
```

因此，可以尝试在 t2 表中针对 m,c1 创建一个索引



##### 基于块的嵌套查询

由于被驱动表会访问多次，一种优化就是尝试将驱动表的部分记录一次加载到内存(**join_buffer_size**)中，在遍历被驱动表时，多个驱动表记录同时批量匹配。

join_buffer 并不会存放所有的列，只存放过滤条件筛选后的列。所以驱动表不要将 * 作为查询列表，只把关心的列放在查询列表中，这样，join buffer 中可以存放更多的记录









### 查询成本

IO成本：数据、索引加载到内存中的损耗
CPU成本：读取记录，筛选出满足条件的记录，排序等操作



##### 基于成本优化步骤

> 1.根据搜索条件，找出所有可能得索引
> 2.计算全表扫描的代价
> 3.计算根据不同索引计算的代码
> 4.调最低的执行



































































































 