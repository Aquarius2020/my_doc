#### 基本思想

将数据划分成若干页,以页为单位作为磁盘和内存之间交互的基本单位.默认 16kb. mysql --initialize 初始化时设置大小,运行时不可改变

#### InnoDB 行格式

> create table 表名(...) row_format=行格式名

##### compact 格式

`变长字段长度列表  |  null 值列表  |  记录头信息  |  列 1  |  列 2  |  ...`

基本上可以看作是行的数据+value 构成

**变长字段长度列表**,字面意思,没啥好说的,这里提一个优化点:

- 变成字段长度表按照逆序排列,这样跟数据段就可以对应上了 
  len1 len2  ...  v2 v1. 可以两边向中间读取

- len 可能占一个或两个字节,具体的编码方式跟 google protocol 编码一样,用第一个位是 0 还是 1 标识是否是一个完成的长度

- 只存非 null 的值

**null 值列表** 

- 用比特位表示是否是 null,也是逆序排放
  1 0 0 ... v3 v2 v1 : 代表 v1 是 null,v2,v3 非 null

- 必须是整数个字节,不够则补充,比如,只有 3 个字段,则需要额外补充 5 位凑够 8 位(1 字节)

**记录头信息**

- 固定 5 个字节,即 40 位,混个脸熟吧,太多了...

#### 真实数据/数据字段

一般情况,除了自己定义的列以外,mysql 还会增加 3 个隐藏列(在最前面添加):

- row_id:没有主键且没有非 null 的 unique 键的话会默认加,用于唯一标识一条记录(隐藏主键)

- trx_id:事务 id,必须得

- roll_pointer: 回归指针

以上三个值都是固定字段且非 null,因此只会出现在数据字段

InnoDB 选择主键策略:默认使用用户定义的,如果没有则选取一个非 null 的 unique 键

补充,char(N) 是否是变长数据取决于数据表字符集,如果是 ascii 就是定长;如果是 utf 那么就是变长. 很好理解,因为 utf 本身就是变长编码格式



redundant 格式








