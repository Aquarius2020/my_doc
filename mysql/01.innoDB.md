#### 基本思想

将数据划分成若干页,以页为单位作为磁盘和内存之间交互的基本单位.默认 16kb. mysql --initialize 初始化时设置大小,运行时不可改变

### InnoDB 行格式 四种

> create table 表名(...) row_format=行格式名

##### compact 格式

`变长字段长度列表  |  null 值列表  |  记录头信息  |  列 1  |  列 2  |  ...`

基本上可以看作是行的数据+value 构成

**变长字段长度列表**,字面意思,没啥好说的,这里提一个优化点:

- 变成字段长度表按照逆序排列,这样跟数据段就可以对应上了 
  len1 len2  ...  v2 v1. 可以两边向中间读取

- len 可能占一个或两个字节,具体的编码方式跟 google protocol 编码一样,用第一个位是 0 还是 1 标识是否是一个完成的长度

- 只存非 null 的值

**null 值列表** 

- 用比特位表示是否是 null,也是逆序排放
  1 0 0 ... v3 v2 v1 : 代表 v1 是 null,v2,v3 非 null

- 必须是整数个字节,不够则补充,比如,只有 3 个字段,则需要额外补充 5 位凑够 8 位(1 字节)

**记录头信息**

- 固定 5 个字节,即 40 位,混个脸熟吧,太多了...

#### 真实数据/数据字段

一般情况,除了自己定义的列以外,mysql 还会增加 3 个隐藏列(在最前面添加):

- row_id:没有主键且没有非 null 的 unique 键的话会默认加,用于唯一标识一条记录(隐藏主键)

- trx_id:事务 id,必须得

- roll_pointer: 回归指针

以上三个值都是固定字段且非 null,因此只会出现在数据字段

InnoDB 选择主键策略:默认使用用户定义的,如果没有则选取一个非 null 的 unique 键

补充,char(N) 是否是变长数据取决于数据表字符集,如果是 ascii 就是定长;如果是 utf 那么就是变长. 很好理解,因为 utf 本身就是变长编码格式



#### redundant 格式

这是一种比较老的格式了，了解即可

|字段长度偏移列表|记录头信息|数据段|

- 计算长度偏移列表

  > 1. 每个字段都会计算**长度**   (包括隐藏字段)
  > 2. 这里的长度并不是直接计算 len，而是通过相邻的两个偏移量之间的差值来计算一个字段的长度，这种看起来存储效率比较高，但是，不太直观，不想 compact 那种直接存储 len 来的直接
  > 3. 长度偏移量也是逆序排列的
  >
  > e.g. 比如 (row_id,trx_id,roll_pointer,c1) 四个列构成的元组，那么他的存放方式为
  >
  > 顺序排列则为 06 0c 13 17， 逆序排列为 17 13 0c 06
  >
  > 这里代表的含义 row_id 占 6 个字节，trx_id 占 0c-06=6个字节，roll_pointer 占 13-0c=7个字节，c1 占 17-13 占 4 个字节
  >
  >   
  >
  > 其实，这样记录还是有很大好处的，这里记录的刚好是 end，那么 file_end - end_i 就可以得到倒数第 i 个位置的 beg，就可以直接读取数据了。
  >
  >  
  >
  > redundant 的长度列表设计缺点：每个 end_i 占用的字节长度是一样的，要不是 1 字节，要不是是 2 字节，这个取决于总的数据长度是否大于 127 字节。2 字节最多记录 32767 个字节，超多的部分会存在**溢出页**中。(因为他搞了一个标志位，所以存储长度就被压缩了)

- 记录头信息

  > 6 字节，共 48 位，也是记录一些标志性信息

- null 值处理

  > null 的偏移量为 1：用第一个 bit 位作为标志位

  感觉把 元数据 放在中间不太好： 怎么快速定位到一条记录的元数据呢？[todo]() 
  读完 char(M) 之后，发现，redunant 根本没有变长这一说，因此，他的元数据可以从 end + value_size 直接定位到

- char(M)

  > 和 compact 不同，redundant 做的比较傻，utf8mb3 char(m) 固定 3m 字节，utf8mb4 char(M) 固定 4m 字节。 相当于原址申请空间了。 不过，这样肯定会造成很大的浪费

- 没有变长，这个就是 不compact 的原因吧

#### dynamic格式、compressed 格式

mysql5.7 之后 dynamic 格式就是默认格式了 `show variables like '%row%'`,

dynamic 与 compact 不同点在于处理溢出数据会把该列的全部数据都放在溢出页中，compress 则是在此基础上做了一个列压缩。

#### 溢出列

记录：   。。。|移除列地址|。。。

#### 总结

- 页是磁盘和内存交互的基本单位，InnoDB 管理的基本单位，默认 16kb



### InnoDB 数据页结构

