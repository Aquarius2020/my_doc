```sql
show variables like 'datadir'
```

每个数据库都对应数据目录下的一个目录或文件夹

创建一个数据库时:

> - 创建一个与数据库同名的子目录
> 
> - 同名目录下创建一个 db.opt 文件:包含数据库的属性,如字符集,比较规则等



#### InnoDB 数据存储

表空间: 表空间指一个表呗存放在某个表下的某些页中;它对应系统中的一个或多个文件.

> 或者可以认为是 硬盘空间 的缓冲池，表空间中存在很多个页，当插入一条记录时就会从缓冲池中回去对应的页写入数据

##### 系统表空间

> 可以配置多个,my.cnf 中可以这样配置
> 
> [server]
> innodb_data_file_path=data1:512M;data2:512M:autoextend
> innodb_data_home_dir=/xxx

ibdata1,初始大小为 12m.这是一个默认的系统表空间.

##### 独立表空间

> 在每个数据库目录下会有一个 表名.ibd 的表空间

##### 其他类型表空间

> 通用表空间,临时表空间等

#### MyISAM 数据存储

同名数据库文件夹中会有一下三个文件

> 表名.frm: 表结构
> 表名.MYD：数据文件
> 表名.MYI：索引文件



#### 文件系统对数据库的影响

有上述内容可以知道，一个数据库对应一个目录，那么目录起名就要受到文件系统的限制，如特殊字符，长度，文件长度等



### 系统数据库介绍

##### mysql

存储 mysql 的用户权限，存储过程，事件定义信息，运行时日志，帮助文档等。

##### information_schema

元数据信息，比如数据库中有哪些表，那些视图，那些列。诸如此类的描述性信息

##### performance_schema

保存运行时而定状态信息，可以用于性能监控。如最近执行了那些语句，执行的每个阶段花费了多长时间，内存使用情况等。

##### sys

通过视图把 information_schema 和 performance_schema 结合起来，方便了解 mysql 的性能信息。





#### InnoDB表空间

**区(extent)** ：对于 16kb 的页来说，连续 64 个页就是一个区，即一个区默认占 1MB 大小；每 256 个区被划分成一组。

> todo 放一张图

- > 第一个组的前三个页面是固定的：
  >
  > - FSP_HDR：这个类型的页面用来登记整个表空间的属性以及本组所有的区的属性。一个表空间只有一个 FSP_HDR 页面
  > - IBUF_BITMAP：用于存储 **Change Buffer**信息
  > - INODE：存储 **INODE Entry**

- > 其余各组的前两个页面是固定的
  >
  > - XDES：extent descriptor。用户记录本组所有区的属性
  > - IBUF_BITMAP

这里引入区的概念是为了让相邻的两个页(最底层的数据链表)在物理上也尽可能相邻，一个区对应物理位置上连续的 64 个页。这样的话可以消除很多随机 io

#### 段

B+ 树的进一步划分，叶子结点和非叶子节点分别存不同的段，分开扫描扫描的数据会少一点。段是管理区的一种方式。

默认情况下，一个聚簇索引被分层两个段，每个段会有 64 个分区，即 1MB 大小。整体上占 2M，但是 2M 空间对于小表会有不少的浪费，因此又引入了碎片区的概念。

#### 碎片区

碎片区中的页面可以属于不同的段，这样样可以最大化利用空间。当一个段有 32 个碎片后就会按照完整的区来分配空间(原有的碎片依旧保留，不会复制)



分区类型：
free: 空闲区，当前分区中的页都是空闲的
free_frag: **碎片区**中有可用页面
full_frag: **碎片区**中所有页都被使用，无空闲页面
fseg: 附属于某个段的区，当数据量很大时使用这种区作为分配的基本单位





##### XDES Entry 结构

> 40 字节，用于描述**当前区**的情况，每个区会有一个
>
> segment id：当前分区属于哪个段
> list node：两个指针，用于构成双向链表
> state：区的类型   (free|free_frag|full_frag|fseg)
> page state bitmap：用于描述 64 个页的状态：是否空闲，是否被用到。每个页有两个位来描述



##### 区的分配过程

插入数据，先看free_frag是否有空闲的碎片区，有的话直接存进去，没有则去申请free碎片区，然后把free碎片区升级为free_frag碎片区，当free_frag碎片区存储满的时候，则会吧free_frag升级为full_frag碎片区。当一个段占用32 个页后就会按照 fseg区分配空间。

为了方便找空闲区，**每个段内**的区会分为三个链表
**free 链表**：当前段内，空闲区构成的链表
**not_full**: 当前段内，被占用，单仍有空闲空间的区构成的链表
**fulll链表**：当前段内没有空闲页面构成的表



#### 段的结构

段是逻辑上的概念，由若干个零散的页面以及一些完整的区组成。于区类似，每个段都会有一个 **inode entry **结构来记录这个段的属性。

**inode entry**

> segment id: 段 id
> not_null_n_used: not_full 链表中已经使用了多少页面
> 3 个 list_base_node：即三种列表对应的头节点
> magic_number：使用一个特殊数字标识该段是否被初始化
> 若干个 fragment_array_entry: 每个这样的解构对应这一个零散的页面，表示他们的页号
















































































