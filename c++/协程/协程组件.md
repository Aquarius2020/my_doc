C++20 ç»ˆäºå¼•å…¥äº†åç¨‹ç‰¹æ€§ï¼Œç»™åº“ä½œè€…æä¾›äº†ä¸€ä¸ªå®ç°åç¨‹çš„æœºåˆ¶ï¼Œè®©ç”¨æˆ·æ–¹ä¾¿ä½¿ç”¨åç¨‹æ¥ç¼–å†™å¼‚æ­¥é€»è¾‘ï¼Œé™ä½äº†å¼‚æ­¥å¹¶å‘ç¼–ç¨‹çš„éš¾åº¦ã€‚ç»“åˆæˆ‘æœ€è¿‘åç¨‹çš„å­¦ä¹ ï¼Œåœ¨è¿™é‡Œè®°å½•ä¸€ä¸‹ç›¸å…³å†…å®¹ã€‚

ä½¿ç”¨åœºæ™¯
åç¨‹å’Œæ™®é€šå‡½æ•°ç›¸æ¯”ï¼Œå¤šäº†ä¸ªä¸­é€”éšæ—¶ æŒ‚èµ· ï¼Œéšå æ¢å¤ çš„è¿‡ç¨‹ï¼Œå½“ç”¨æˆ·è°ƒç”¨ä¸€ä¸ªé˜»å¡è¯·æ±‚æ¥å£ï¼Œä»è€Œè®©å‡ºæ§åˆ¶æƒï¼Œå½“å“åº”æ—¶ï¼Œæ¢å¤ä¹‹å‰çš„æ§åˆ¶æµï¼Œä»è€Œå¤§å¤§æé«˜çº¿ç¨‹å¤ç”¨ç‡ï¼Œè¿™ä¹Ÿæ³¨æ„äº†åç¨‹åªæ˜¯å¹¶å‘çš„ï¼Œå¹¶ä¸æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„å¹¶è¡Œï¼Œåœ¨ IO å¯†é›†å‹åœºæ™¯ä¸‹ï¼Œåç¨‹èƒ½å¤Ÿå¾ˆå¥½çš„æé«˜èµ„æºåˆ©ç”¨ç‡ï¼Œç”¨å°‘æ•°çš„çº¿ç¨‹è¾¾åˆ°å¹¶å‘æˆç™¾ä¸Šä¸‡ä¸ªåç¨‹çš„æ•ˆæœã€‚

è€Œç›¸å¯¹ä¼ ç»Ÿçš„çº¿ç¨‹æ±  + å›è°ƒæ¨¡å¼ï¼Œæ¯å‘èµ·ä¸€ä¸ªè¯·æ±‚ï¼Œä¸ºäº†é¿å…é˜»å¡å½“å‰çº¿ç¨‹ï¼Œéœ€è¦æŒ‚ä¸€ä¸ªå›è°ƒå‡½æ•°å¤„ç†åç»­è¿‡ç¨‹ï¼Œè€Œå›è°ƒå‡½æ•°åˆå¯èƒ½äº§ç”Ÿç«äº‰ï¼Œå¯¼è‡´å¾—åŠ é”å¤„ç†ã€‚è€Œåç¨‹å´èƒ½å¤Ÿä»¥åŒæ­¥æ–¹å¼å†™å®ç°å¼‚æ­¥ï¼Œåç»­è¿‡ç¨‹ç›´æ¥æŒ‚èµ·ï¼Œå½“å“åº”çš„æ—¶å€™æ¢å¤æ‰§è¡Œã€‚

æˆ‘å‚ä¸çš„é¡¹ç›®ä¸­ï¼Œå¯¹è±¡éšæ—¶éƒ½å¯èƒ½èµ·ä¸ªçº¿ç¨‹å¹²æ´»ï¼Œæˆ–è€…å¸¸é©»äºå¯¹è±¡ç”Ÿå‘½å‘¨æœŸé‡Œï¼Œç»Ÿè®¡ä¸‹æ¥æ•´ä¸ªé¡¹ç›®å±…ç„¶å¼€äº†å‡ ç™¾ä¸ªçº¿ç¨‹ï¼Œç”±äºå¤šçº¿ç¨‹ç¼–ç¨‹éš¾å…å¯¼è‡´ç«äº‰ï¼Œä»è€Œéœ€è¦é”è¿™ç§å¾ˆä½çº§çš„æœºåˆ¶åšåŒæ­¥ï¼Œè€Œä¸€æ—¦å¼•å…¥äº†é”ï¼Œå°±ä¸å¯é¿å…çš„æ‰©æ•£å¼€æ¥ï¼Œå¤§å®¶çœ‹åˆ°è¿™é‡ŒåŠ æŠŠé”ï¼Œé‚£æˆ‘ä¹ŸåŠ æŠŠé”ï¼Œç»Ÿè®¡ä¸‹æ¥ä»£ç é‡Œé¢å±…ç„¶ä¹Ÿæœ‰å‡ ç™¾æŠŠé”ã€‚ã€‚çœŸæ˜¯ç»´æŠ¤çš„å™©æ¢¦å•ŠğŸ¤£

ç”±äºåç¨‹èƒ½å¤Ÿéšæ—¶æŒ‚èµ·ï¼Œåç»­æ¢å¤ï¼Œè¿™å°±èƒ½å®ç°ä¸€äº›å»¶è¿Ÿè®¡ç®—çš„ç‰¹æ€§ï¼Œä¾‹å¦‚ç”Ÿæˆå™¨ã€‚

æ‰¯è¿œäº†ï¼Œæœ¬æ–‡ä¸»é¢˜æ˜¯å…³äº C++20 çš„åç¨‹ï¼Œåœ¨ C++20 è¿˜æ²¡ç¨³å®šä¹‹å‰ï¼Œå…ˆæ¥å­¦ä¹ ä¸€ä¸‹ç›¸å…³çŸ¥è¯†ï¼Œè¯»å®Œæœ¬æ–‡åä½ åº”è¯¥èƒ½åˆ©ç”¨è¿™ä¸ªæœºåˆ¶å®ç°ä¸€äº›æƒ³è¦çš„åç¨‹äº†ã€‚

æ¦‚å¿µæ¨¡å‹
C++20 çš„åç¨‹è®¾è®¡ä¸ºæ— æ ˆåç¨‹ï¼Œç›¸å¯¹äºæœ‰æ ˆåç¨‹ï¼Œçœæ‰äº†ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€[1]ï¼Œåªèƒ½æ‰‹åŠ¨åˆ‡æ¢ï¼Œæ•ˆç‡æ›´é«˜ï¼Œä¹Ÿä¸ç”¨ç®¡ç†å¤æ‚çš„å¯„å­˜å™¨çŠ¶æ€ï¼Œç§»æ¤æ€§æ›´å¥½ï¼Œä½†è¿™åŒæ—¶ä¹Ÿå¯¼è‡´äº†ä¸èƒ½è¢«éåç¨‹å‡½æ•°åµŒå¥—è°ƒç”¨ã€‚

åŒæ—¶å¼•å…¥äº† 3 ä¸ªå…³é”®å­—ï¼š

co_yield: æŒ‚èµ·å¹¶è¿”å›å€¼
co_await: æŒ‚èµ·
co_return: ç»“æŸåç¨‹
å½“ä¸€ä¸ªå‡½æ•°å‡ºç°äº†ä¸Šé¢çš„å…³é”®å­—ï¼Œåˆ™è¯¥å‡½æ•°æ˜¯ä¸ªåç¨‹ã€‚

Promise
å½“ caller è°ƒç”¨ä¸€ä¸ª callee åç¨‹çš„æ—¶å€™ï¼Œåç¨‹è‡ªèº«çš„çŠ¶æ€ä¿¡æ¯ [2]ï¼ˆå½¢å‚ï¼Œå±€éƒ¨å˜é‡ï¼Œè‡ªå¸¦æ•°æ®ï¼Œå„ä¸ªé˜¶æ®µç‚¹æ‰§è¡Œç‚¹ï¼‰ä¼šè¢«ä¿å­˜åœ¨å †ä¸Šçš„ Promise å¯¹è±¡ä¸­ï¼Œè¿™ä¹Ÿæ˜¯ç¼–è¯‘å™¨ä¼šåœ¨åç¨‹é‡Œé¢æ’å…¥ Promise ç›¸å…³ä»£ç ï¼Œä»¥åŠä¸€äº›æ‰§è¡Œç‚¹ã€‚ç”±äº Promise çš„å¤§å°å¯ä»¥åœ¨ç¼–è¯‘æœŸè®¡ç®—å‡ºæ¥ï¼Œä»è€Œé¿å…äº†å†…å­˜æµªè´¹ã€‚è€Œ Promise å¯¹è±¡æ‰€æœ‰æƒå¯ç”±coroutine_handle å¥æŸ„æŒæœ‰ã€‚

Future
è€Œ Future å¯¹è±¡ä¸»è¦æ˜¯ä¸ Promise å¯¹è±¡äº¤äº’çš„æ¡¥æ¢ï¼Œæ—¢ caller ä¸ callee ä¹‹é—´çš„é€šä¿¡ï¼š

callee æŒ‚èµ·æ—¶ï¼Œå°†å€¼è¿”å›ç»™ caller: yield è¯­ä¹‰
callee æ‰§è¡Œç»“æŸæ—¶ï¼Œå°†å€¼è¿”å›ç»™ caller: return è¯­ä¹‰
callee æ¢å¤æ—¶ï¼Œcaller å°†å€¼å¸¦ç»™ callee
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™äº›æ¦‚å¿µå’Œæ ‡å‡†åº“çš„ std::promise/std::future ä¸æ˜¯åŒä¸€ä¸ªä¸œè¥¿ï¼Œåè€…ç”¨äºåšåŒæ­¥ç”¨ï¼Œstd::futureä¼šé˜»å¡ç­‰å¾…ç›´åˆ° std::promise æä¾›å€¼ï¼Œå¯ä»¥çœ‹åšæ˜¯æ¡ä»¶å˜é‡çš„å°è£…ï¼ŒåŒæ ·åœ°ï¼Œå’Œå…¶ä»–è¯­è¨€çš„ Promise/Future æ¦‚å¿µä¹Ÿä¸ä¸€æ ·ã€‚

Awaitable
å¦‚æœä¸€ä¸ªå¯¹è±¡æ˜¯ Awaitable å¯¹è±¡ï¼Œé‚£ä¹ˆå¯ä»¥ç”¨ co_await æ“ä½œç¬¦å»è§¦å‘è¯¥å¯¹è±¡çš„åŠ¨ä½œ ready/suspend/resumeï¼Œä»è€Œè½¬ç§»ã€æ¢å¤æ§åˆ¶æƒï¼Œco_await ç»†èŠ‚ç•™åˆ°åé¢åœ¨ä»‹ç»ã€‚

å…·ä½“æœºåˆ¶
äº†è§£äº†æ¦‚å¿µæ¨¡å‹åï¼Œæˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥æ¢è®¨èƒŒåçš„æœºåˆ¶äº†ã€‚

Promise/Future å¯¹è±¡
å½“ä¸€ä¸ªåç¨‹è¢«è°ƒç”¨æ—¶ï¼Œä¼šåˆ›å»º Promise å¯¹è±¡ï¼Œç„¶åç¼–è¯‘å™¨ä¼šåœ¨å„ä¸ªé˜¶æ®µæ’å…¥ä¸€äº›ä»£ç [3]ï¼š

{
co_await promise.initial_suspend();
try
{
<body-statements>
}
catch (...)
{
promise.unhandled_exception();
}
FinalSuspend:
co_await promise.final_suspend();
}
å¯ä»¥çœ‹åˆ°ä¸€ä¸ªåç¨‹å‡½æ•°ï¼Œåˆ†ä¸ºå¦‚ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š

ä»å †ä¸Š (operator new) åˆ›å»º Promise å¯¹è±¡ï¼Œä¿å­˜åç¨‹çš„çŠ¶æ€ä¿¡æ¯
initial_suspend é˜¶æ®µï¼Œç”¨äºåœ¨æ‰§è¡Œåç¨‹ä¸»ä½“ <body-statements> ä»£ç å‰åšäº›äº‹æƒ…
<body-statements>é˜¶æ®µï¼Œæ‰§è¡Œåç¨‹çš„ä¸»ä½“ä»£ç 
unhandled_exception é˜¶æ®µï¼Œè‹¥æŠ›å¼‚å¸¸ï¼Œå¤„ç†å¼‚å¸¸
final_suspend é˜¶æ®µï¼Œåç¨‹ç»“æŸæ”¶å°¾åŠ¨ä½œï¼Œåœ¨è¿™é˜¶æ®µçš„ coroutine_handle<Promise>::done æ–¹æ³•ä¸º trueï¼Œcaller å¯ä»¥é€šè¿‡è¿™ä¸ªæ–¹æ³•åˆ¤æ–­åç¨‹æ˜¯å¦ç»“æŸï¼Œä»è€Œä¸å†è°ƒç”¨ resume æ¢å¤åç¨‹.
final_suspend å¦‚æœæ²¡æœ‰æŒ‚èµ·,åˆ™ç›´æ¥é€€å‡ºçŠ¶æ€,ç´§æ¥ç€ä¼šé‡Šæ”¾åç¨‹å¸§. åŒæ—¶,ç”±äºæ²¡æœ‰åœ¨ final_suspend å¤„æŒ‚èµ·, done() è¿”å› false.  å…¶å®,done çš„å«ä¹‰æ›´åƒæ˜¯åˆ¤æ–­åç¨‹æœ‰ç±³æœ‰æŒ‚èµ·åœ¨æœ€åé˜¶æ®µ
è€Œåç¨‹è¿”å›ç±»å‹åˆ™æ˜¯ä¸€ä¸ª Future å¯¹è±¡ï¼Œè¿™ä¸€æ­¥ç¼–è¯‘å™¨é€šè¿‡ Promise::get_return_object() æ¥åˆ›å»º Future å¯¹è±¡ã€‚è€Œ Future å¯¹è±¡ä¸€èˆ¬æŒæœ‰ Promise çš„å¥æŸ„ï¼šcoroutine_handle<Promise>ï¼Œè¿™æ · caller å¯ä»¥é€šè¿‡ Future ä¸ Promise äº¤äº’ï¼Œä»è€Œæ¢å¤åç¨‹ã€‚

è€Œ Promise å¯¹è±¡é‡Šæ”¾çš„æ—¶é—´ç‚¹æœ‰ä¸¤ä¸ªï¼Œé¿å…é‡å¤æ‰§è¡Œï¼Œå¦åˆ™ä¼š double freeï¼š

final_suspend é˜¶æ®µ resume å
è°ƒç”¨ coroutine_handle<Promise>::destroy() æ–¹æ³•
æ¯”è¾ƒå¥½çš„åšæ³•æ˜¯åœ¨ final_suspend é˜¶æ®µæŒ‚èµ·ï¼Œè¿™æ—¶å€™å°±ä¸å¯ resume äº†ï¼Œåœ¨ caller é€šè¿‡è°ƒç”¨ Future æŒæœ‰çš„å¥æŸ„ destroy() æ–¹æ³•é‡Šæ”¾ Promise å¯¹è±¡ã€‚

ç»¼ä¸Šï¼Œä¸€ä¸ª Promise å¯¹è±¡éœ€è¦å®ç°å¦‚ä¸‹æ–¹æ³•ï¼š

initial_suspend: è¿”å›ä¸€ä¸ª Awaitable å¯¹è±¡
final_suspend: è¿”å›ä¸€ä¸ª Awaitable å¯¹è±¡
get_return_object: è¿”å›ä¸€ä¸ª Future å¯¹è±¡ç»™ caller
unhandled_exception: å¤„ç†å¼‚å¸¸
return_value/return_void: co_return æ—¶è¿”å›å€¼ç»™ caller
yield_value: æŒ‚èµ·æ—¶è¿”å›å€¼ç»™ caller
å†æ¥çœ‹çœ‹å…¶ coroutine_handle<Promise> å¥æŸ„ç¼–è¯‘å™¨æä¾›äº†å“ªäº›ä¸»è¦æ–¹æ³•ï¼š

destroy: é”€æ¯ Promise å¯¹è±¡
from_promise: é™æ€æ–¹æ³•ï¼Œä» Promise å¯¹è±¡è¿”å›å…¶ coroutine_handle å¥æŸ„
done: æ˜¯å¦å¤„äº final_suspend é˜¶æ®µ
promise: è¿”å› Promise å¯¹è±¡å¼•ç”¨
resume/operator(): æ¢å¤åˆ°åç¨‹
Awaitable å¯¹è±¡
å‰é¢æåˆ°çš„ co_await å…³é”®å­—[4]ï¼Œå…¶æ“ä½œçš„å¯¹è±¡å…¶å®æ˜¯ Awaiter å¯¹è±¡ï¼Œè‹¥å¯¹è±¡å®ç°å¦‚ä¸‹æ–¹æ³•ï¼Œåˆ™è¯´æ˜è¯¥å¯¹è±¡æ˜¯ Awaitable çš„ï¼š

await_ready
await_suspend(coroutine_handle<>)
await_resume
é‚£ä¹ˆå½“æ‰§è¡Œ co_await <expr> è¡¨è¾¾å¼æ—¶ï¼Œç¼–è¯‘å™¨ä¼šç”Ÿæˆå¦‚ä¸‹ä»£ç ï¼š

{
auto&& value = <expr>;
auto&& awaitable = get_awaitable(promise, static_cast<decltype(value)>(value));
auto&& awaiter = get_awaiter(static_cast<decltype(awaitable)>(awaitable));
if (!awaiter.await_ready())
{
<suspend-coroutine>

    //if await_suspend returns void
    try {
        awaiter.await_suspend(coroutine_handle);
        return_to_the_caller();
    } catch (...) {
        exception = std::current_exception();
        goto resume_point;
    }
    //endif
    //if await_suspend returns bool
    bool await_suspend_result;
    try {
        await_suspend_result = awaiter.await_suspend(coroutine_handle);
    } catch (...) {
        exception = std::current_exception();
        goto resume_point;
    }
    if (not await_suspend_result)
        goto resume_point;
    return_to_the_caller();
    //endif
    //if await_suspend returns another coroutine_handle
    decltype(awaiter.await_suspend(std::declval<coro_handle_t>())) another_coro_handle;
    try {
        another_coro_handle = awaiter.await_suspend(coroutine_handle);
    } catch (...) {
        exception = std::current_exception();
        goto resume_point;
    }
    another_coro_handle.resume();
    return_to_the_caller();
    //endif
}
resume_point:
if(exception)
std::rethrow_exception(exception);
"return" awaiter.await_resume();
}
ä¹Ÿå°±æ˜¯ï¼š

é€šè¿‡ <expr> æ‹¿åˆ° Awaiter å¯¹è±¡
é€šè¿‡ Awaiter.await_ready()æ–¹æ³•åˆ¤æ–­æ˜¯å¦éœ€è¦æŒ‚èµ·ï¼Œè‹¥ä¸º true åˆ™æ— éœ€æŒ‚èµ·
åˆ¤æ–­ Awaiter.await_suspend()çš„è¿”å›å€¼ç±»å‹ï¼š
voidï¼Œæ— è¿”å›å€¼ï¼Œç›´æ¥æŒ‚èµ·è¿”å› caller
boolï¼Œè‹¥ä¸º trueï¼Œåˆ™è¿”æŒ‚èµ·è¿”å› callerï¼Œå¦åˆ™ä¸æŒ‚èµ·ï¼Œç›´æ¥ resume
coroutine_handle<>, åˆ™æŒ‚èµ·å¹¶å°†æ§åˆ¶æƒè½¬ç§»åˆ°å¦ä¸€ä¸ªåç¨‹ä¸Šï¼Œå¦ä¸€ä¸ªåç¨‹å¯ä»¥å† resume å›æ¥ï¼Œåˆ°è¾¾resume_pointã€‚
Awaiter.await_resume()çš„è¿”å›å€¼å³ä¸º co_await çš„ç»“æœ
é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œè°æ¥åˆ›å»º Awaiter å¯¹è±¡å‘¢ï¼Ÿæœ‰ä¸¤ç§æ–¹æ³•ï¼š

é€šè¿‡ Promise å¯¹è±¡çš„ await_transform(<expr>) æ–¹æ³•ï¼Œå¾—åˆ° Awaiter å¯¹è±¡
é€šè¿‡é‡è½½ operator co_await æ“ä½œç¬¦ï¼Œå¾—åˆ° Awaiter å¯¹è±¡
ç›´æ¥ç”¨ Awaitable å¯¹è±¡
æ ‡å‡†åº“é‡Œé¢å®ç°äº†ä¸¤ç§ Awaiterï¼Œåˆ†åˆ«å¦‚ä¸‹ï¼š

struct suspend_never {
bool await_ready() const { return true; }
void await_suspend(coroutine_handle<>) const {}
void await_resume() const {}
};

struct suspend_always {
bool await_ready() const { return false; }
void await_suspend(coroutine_handle<>) const {}
void await_resume() const {}
};
ä¸»è¦åœ¨ await_ready é˜¶æ®µåˆ¤æ–­æ˜¯å¦éœ€è¦æŒ‚èµ·åç¨‹ã€‚

æœ€å co_yield <expr> å…¶å®æ˜¯ co_await çš„è¯­æ³•ç³–ï¼Œç”Ÿæˆå¦‚ä¸‹ä»£ç ï¼š

co_await promise.yield_value(expression);
è€Œ co_return åˆ™ä¼šè°ƒç”¨ Promise å¯¹è±¡çš„ return_void/return_value æ–¹æ³•ã€‚

åç¨‹å®æˆ˜
æœ‰äº†ä»¥ä¸ŠçŸ¥è¯†ï¼Œåº”è¯¥è¶³å¤Ÿå®ç°ä¸€äº›åç¨‹äº†ã€‚

ä¸ºäº†ç®€å•èµ·è§ï¼Œè¿™é‡Œæˆ‘å®ç°ä¸€ä¸ª Fibonacci çš„ç”Ÿæˆå™¨ï¼Œå®Œæ•´ä»£ç å¯ä»¥è§ï¼š https://github.com/netcan/recipes/blob/master/cpp/coroutine/FibonacciGen.cpp

é¦–å…ˆå…ˆå†™åç¨‹å‡½æ•°ï¼Œå¹¶åœ¨ main caller ä¸­è°ƒç”¨ï¼Œå†…å®¹å¦‚ä¸‹ï¼š

FiboFuture generate_fibo() {
int i = 0, j = 1;
while (true) {
co_yield j;
std::tie(i, j) = std::make_pair(j, i + j);
}
}

int main() {
for (auto x = generate_fibo(); x < 1000; x.resume())
std::cout << "fibo:" << x << std::endl;
return 0;
}
æ¥ç€å®ç°æˆ‘ä»¬æ‰€éœ€è¦çš„ Proimse å¯¹è±¡ï¼Œç”¨äºå°†ç»“æœä¼ ç»™ callerï¼š

struct promise_type {
int value_; // è¿”å›ç»“æœç»™ caller
auto initial_suspend() { return suspend_never{}; }
auto final_suspend() noexcept { return suspend_always{}; } // final_suspend æŒ‚èµ·ï¼Œç”± FiboFuture é‡Šæ”¾ promise å¯¹è±¡
FiboFuture get_return_object()
{ return {coroutine_handle<promise_type>::from_promise(*this)}; } // è¿”å› FiboFuture å¯¹è±¡
void unhandled_exception() { std::terminate(); }

    auto yield_value(int value) { // yield ä¸€ä¸ªå€¼å¹¶æŒ‚èµ·è¿”å› caller
        value_ = value;
        return suspend_always{};
    }
    void return_void() {}
};
è¿˜æœ‰å¯¹åº”çš„ Futureï¼š

struct FiboFuture {
struct promise_type;
FiboFuture(coroutine_handle<promise_type> handle): handle_(handle) {}

    operator int() { return handle_.promise().value_; }
    void resume() { if (! handle_.done()) handle_.resume(); }
    ~FiboFuture() { handle_.destroy(); }
private:
coroutine_handle<promise_type> handle_;
};
ä¸€åˆ‡æå®šï¼Œè¿™å°±æ˜¯ç›®å‰ç”Ÿæˆå™¨çš„å®ç°ï¼Œå¾…åç»­é›†æˆåˆ°æ ‡å‡†åº“ä¸­å»ï¼Œæ–¹ä¾¿ä½¿ç”¨ã€‚

è¿˜æœ‰ä¸€ä¸ªä¾‹å­æ˜¯ caller/callee ç›¸äº’åä½œï¼Œäº’ç›¸é€šä¿¡å®Œæˆä»»åŠ¡ï¼Œå…·ä½“è§ï¼š https://github.com/netcan/recipes/blob/master/cpp/coroutine/DoubleClick.cpp

æ€»ç»“
æœŸå¾… C++20 åç¨‹çš„ç¨³å®šæˆç†Ÿï¼Œè¿™æ ·å†™ä¸šåŠ¡ä»£ç å°±ç®€å•å¤šäº†ï¼Œå¿ƒæ™ºè´Ÿæ‹…æ²¡é‚£ä¹ˆé‡äº†ã€‚

æœ‰æ ˆåç¨‹ä¸æ— æ ˆåç¨‹ â†©ï¸

Introduction to C++ Coroutines - James McNellis â†©ï¸

C++ Coroutines: Understanding the promise type â†©ï¸

CO_AWAITING COROUTINES â†©ï¸

