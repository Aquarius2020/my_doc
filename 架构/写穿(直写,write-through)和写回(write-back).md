CPU使用高速缓存(**DCache**)时，它对内存的的写操作有两种模式：写穿(write-throuht)、写回(write-back)。

### 写穿(write-throuht)模式

该模式下，CPU对主存写数据时，不经过DCdcache直接写到内存，此时对于写的实现比较简单，如果系统只用写穿模式的话，DCache则变成了读缓存了。

### 写回(write-back)模式

CPU写入数据时，不直接将数据写入内存，而是写入DCdcache，当dcache数据被替换出去时才写回主存。 
此时存在一个问题，并不是所有的dcache中的数据都被修改过，因此没必要把所有替换出去的数据都重新写入主存。 
为了表示哪些数据被修改过(dcache中是数据和主存中的数据是否不一致)，dcache中每一块增加了一个记录信息位，CPU修改过的DCdcache时，设置此记录信息位(此时数据块为脏的(dirty), cache数据写入到主存时清理此位(此时数据块为干净的(clean)。 
有了次记录信息位，数据从dcache替换到主存时只替换脏的数据块即可)，

**为什么有写回模式** 
大家都是知道cache速度远大于RAM(主存)。通过DCache吸收系统的写操作，在必要的时候再统一写入主存，从而减少频繁的相对较慢的对主存的写操作，这样明显能加速系统。**同样的思想在主存与磁盘中也存在。**

#### 比较：

现在系统中，写回策略设置了写缓冲器，减少了访问主存的次数，但是写通方式设计比较容易，维护数据的一致性跟简单。

##### **WB（write back）+WA（write allocation）** 

![è¿éåå¾çæè¿°](pic/写穿(直写,write-through)和写回(write-back)/SouthEast.png)

若存在缓存，即CPU先访问缓存， 
1.当请求是读请求时，若命中，直接返回其数据；当未命中时，先再缓存中分配一个缓存快，判断当前缓存块是不是脏数据（被修改过的数据），如果是，将之前的数据写回下一级存储中，如果不是脏数据，直接从下一级存储中读到cache块中，修改dirty位为，clean（未被修改）；返回数据。

2.当请求是写请求时，若命中，直接将新数据写入缓存，并且标记dirt位为，dirty（被修改）；若未命中，分配一块缓存块，，判断当前缓存块是不是脏数据，如果是，将之前的数据写回下一级存储中，如果不是脏数据，直接从下一级存储中读到cache块中，将新数据写入缓存块，并标记为dirty。

##### **WT（write through )+WN(write no allocation)**  

![这里写图片描述](pic/写穿(直写,write-through)和写回(write-back)/SouthEast-20230421133857656.png)



1.解释与wb类似









- **Cache Aside模式**

1. 读取失效：cache数据没有命中，查询DB，成功后把数据写入缓存
2. 读取命中：读取cache数据
3. 更新：把数据更新到DB，失效缓存

![img](pic/写穿(直写,write-through)和写回(write-back)/cache-1.png)











